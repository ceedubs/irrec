package ceedubs.irrec
package regex
package gen

import org.scalacheck.{Arbitrary, Cogen, Gen}
import cats.Order
import cats.implicits._

final case class RegexAndCandidate[In, Out](r: RegexM[In, Out], candidate: Stream[In])

object RegexAndCandidate {

  /**
   * Generate a regular expression and a stream that matches the regular expression.
   */
  def genRegexAndMatch[In: Cogen: Order, Out: Arbitrary: Cogen](
    cfg: RegexGen.Config[In],
    matchToGen: Match[In] => Gen[In]): Gen[RegexAndCandidate[In, Out]] =
    for {
      r <- RegexGen.genRegex[In, Out](cfg)
      c <- RegexMatchGen.regexMatchingStreamGen(matchToGen)(r)
    } yield RegexAndCandidate(r, c)

  def genIntRegexAndMatch[Out: Arbitrary: Cogen]: Gen[RegexAndCandidate[Int, Out]] =
    genRegexAndMatch(RegexGen.standardIntConfig, RegexMatchGen.intMatchingGen)

  // TODO universal instead of existential type for Regex[In, _]?
  /**
   * About half of the streams generated by this generator will match the provided regular
   * expression. The other half will be random streams which _could_ match the expression but are
   * unlikely to.
   *
   * @see also [[genRegexAndMatch]].
   */
  def genCandidateStream[In](matchToGen: Match[In] => Gen[In]): RegexM[In, _] => Gen[Stream[In]] = {
    val matching = RegexMatchGen.regexMatchingStreamGen(matchToGen)
    r => Gen.oneOf(matching(r), Gen.containerOf[Stream, In](matchToGen(Match.wildcard)))
  }

  /**
   * Generates arbitrary regexes and candidate matches for the regex. The candidate will match the
   * regex roughly 50% of the time.
   */
  def genRegexAndCandidate[In: Cogen: Order, Out: Arbitrary: Cogen](
    cfg: RegexGen.Config[In],
    matchToGen: Match[In] => Gen[In]): Gen[RegexAndCandidate[In, Out]] = {
    val probablyNotMatching = for {
      r <- RegexGen.genRegex[In, Out](cfg)
      c <- Gen.containerOf[Stream, In](cfg.gen)
    } yield RegexAndCandidate(r, c)

    Gen.oneOf(probablyNotMatching, genRegexAndMatch[In, Out](cfg, matchToGen))
  }

  implicit def arbRegexAndCandidate[In, Out](
    implicit arbRegex: Arbitrary[RegexM[In, Out]],
    candidateGen: RegexCandidates[In, Match[In]]): Arbitrary[RegexAndCandidate[In, Out]] =
    Arbitrary(
      for {
        r <- arbRegex.arbitrary
        candidate <- candidateGen.genCandidateStream(r)
      } yield RegexAndCandidate(r, candidate)
    )
}
